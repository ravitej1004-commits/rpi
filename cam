import time
import serial
import pynmea2
import RPi.GPIO as GPIO
import sys
from RPLCD.i2c import CharLCD
import cv2
import os
import mediapipe as mp # New MediaPipe import

# Initialize MediaPipe solutions
mp_face_detection = mp.solutions.face_detection
mp_drawing = mp.solutions.drawing_utils

# --- CONFIGURATION ---
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TARGET_PHONE_NUMBER = "+919876543210" # üö® MANDATORY: UPDATE THIS NUMBER!
IMAGE_SAVE_PATH = "/home/pi/interlock_proofs/" # Directory to save evidence images
# CASCADE_PATH is no longer needed as we use MediaPipe
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

MQ3_D0_ALARM_THRESHOLD = GPIO.LOW    # MQ-3 D0 pin usually goes LOW when alarm triggers
TEST_WINDOW = 5                      # Duration of initial alcohol test in seconds

# --- PINS & PORTS ---
MQ3_PIN = 24                         # MQ3 digital output (D0)
RELAY_PIN = 23                       # Controls vehicle interlock
LED_PIN = 18                         # Status LED

GSM_PORT = "/dev/ttyUSB0"            # GSM module serial port
GPS_PORT = "/dev/ttyAMA3"            # GPS module serial port
BAUD_RATE = 9600

# --- RELAY LOGIC DEFINITION (HIGH = Lock, LOW = Unlock) ---
RELAY_LOCKED_STATE = GPIO.HIGH
RELAY_UNLOCKED_STATE = GPIO.LOW

# --- SETUP ---
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Outputs: Relay and LED
GPIO.setup(RELAY_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.output(RELAY_PIN, RELAY_LOCKED_STATE)    
GPIO.output(LED_PIN, GPIO.LOW)       # LED OFF

# Input: MQ-3 Digital Output
GPIO.setup(MQ3_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP) 

# Hardware and Global Variables
lcd = None
gps_serial = None
gsm_serial = None
camera = None
face_detector = None # Changed from face_cascade
last_detected_frame = None  # To store the last frame where a face was seen

current_lat = "No GPS Fix"
current_lon = ""

# 1. Initialize LCD
try:
    lcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)
    lcd.clear()
    print("[System] LCD Connected.")
except Exception:
    print("[ERROR] LCD Error.")

# 2. Initialize Serial Ports
try:
    gps_serial = serial.Serial(GPS_PORT, BAUD_RATE, timeout=0.1)
    gsm_serial = serial.Serial(GSM_PORT, BAUD_RATE, timeout=1)
    print("[System] Serial Ports Opened.")
except serial.SerialException:
    print("[CRITICAL ERROR] Serial Port Initialization Failed.")

# 3. Initialize Camera and MediaPipe Detector
try:
    if not os.path.exists(IMAGE_SAVE_PATH):
        os.makedirs(IMAGE_SAVE_PATH)
        print(f"[System] Created proof directory: {IMAGE_SAVE_PATH}")
        
    camera = cv2.VideoCapture(0)  # 0 is usually the default camera index
    if not camera.isOpened():
        raise IOError("Cannot open webcam")
    
    # Initialize MediaPipe Face Detection model
    face_detector = mp_face_detection.FaceDetection(
        model_selection=0, # 0 for short-range (up to 2 meters)
        min_detection_confidence=0.7 # High confidence for security
    )
    
    print("[System] Camera & Face Detector Initialized (MediaPipe).")
except Exception as e:
    camera = None
    face_detector = None
    print(f"[ERROR] Camera/MediaPipe Setup Failed: {e}. Running without camera.")


# --- HELPER FUNCTIONS ---

def safe_lcd_write(line1, line2=""):
    """Writes to LCD safely, ignoring errors."""
    if lcd:
        try:
            lcd.clear()
            lcd.write_string(line1.ljust(16))
            lcd.cursor_pos = (1, 0)
            lcd.write_string(line2.ljust(16))
        except Exception:
            pass

def update_gps():
    """Reads GPS data non-blockingly using pynmea2."""
    global current_lat, current_lon
    if not gps_serial or not gps_serial.is_open:
        return

    while gps_serial.in_waiting > 0:
        try:
            line = gps_serial.readline().decode('utf-8', errors='replace').strip()
            if line.startswith('$GPGGA'):
                msg = pynmea2.parse(line)
                if msg.gps_qual > 0:
                    current_lat = str(round(msg.latitude, 5))
                    current_lon = str(round(msg.longitude, 5))
        except Exception: 
            pass

def send_sms_alert():
    """Sends SMS alert with location using robust timing."""
    if not gsm_serial or not gsm_serial.is_open:
        safe_lcd_write("SMS FAILED", "GSM Error")
        return

    safe_lcd_write("ALARM! Sending SMS", f"Loc: {current_lat}")
    print("\n\n‚ö† SENDING SMS ALERT...")
    
    try:
        gsm_serial.write(b'AT+CMGF=1\r\n')
        time.sleep(0.5)
        gsm_serial.read_all()
        gsm_serial.write(f'AT+CMGS="{TARGET_PHONE_NUMBER}"\r\n'.encode('utf-8'))
        time.sleep(0.5) 
        
        if current_lat == "No GPS Fix":
            loc_msg = "Location: No GPS Fix."
        else:
            loc_msg = f"Location: https://maps.google.com/?q={current_lat},{current_lon}"
            
        message = f"VEHICLE INTERLOCK FAILURE! Alcohol Detected.\n{loc_msg}"
        gsm_serial.write(message.encode('utf-8'))
        time.sleep(0.5) 
        gsm_serial.write(bytes([26])) 
        time.sleep(5.0) 
        response = gsm_serial.read_all().decode('utf-8', errors='ignore').strip()
        if "OK" in response or "+CMGS" in response:
            print("‚úÖ SMS Sent OK.")
        else:
            print(f"‚ùå SMS Failed. Response: {response}")
            
    except Exception as e:
        print(f"[ERROR] SMS Function Error: {e}")

# --- MAIN ROUTINE ---
def start_system():
    global last_detected_frame
    print("\n--- VEHICLE INTERLOCK SYSTEM ACTIVE ---")
    safe_lcd_write("INTERLOCK LOCKED", f"Blow Now! ({TEST_WINDOW}s)")

    start_time = time.time()
    
    # Test Loop: User must blow for the full duration
    while (time.time() - start_time) < TEST_WINDOW:
        remaining = int(TEST_WINDOW - (time.time() - start_time)) + 1
        
        mq3_state = GPIO.input(MQ3_PIN)
        update_gps()

        # CAMERA AND FACE DETECTION LOGIC (MediaPipe)
        is_face_detected = False
        if camera and camera.isOpened() and face_detector:
            ret, frame = camera.read()
            if ret:
                # 1. Convert BGR image to RGB (MediaPipe requirement)
                frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                
                # 2. Process the frame with MediaPipe Face Detection
                results = face_detector.process(frame_rgb)
                
                # Create a local copy for drawing annotations
                annotated_frame = frame.copy() 

                if results.detections:
                    is_face_detected = True
                    
                    # 3. Draw bounding boxes returned by MediaPipe
                    for detection in results.detections:
                        mp_drawing.draw_detection(annotated_frame, detection)
                    
                    # Store the annotated frame for proof
                    last_detected_frame = annotated_frame 
                else:
                    # Store the clean frame if no face is detected
                    last_detected_frame = frame
                    
            print(f"Time: {remaining}s | D0: {'ALARM' if mq3_state == MQ3_D0_ALARM_THRESHOLD else 'Clear'} | GPS: {current_lat} | Face: {is_face_detected}", end="\r")
        else:
            print(f"Time: {remaining}s | D0: {'ALARM' if mq3_state == MQ3_D0_ALARM_THRESHOLD else 'Clear'} | GPS: {current_lat}", end="\r")

        
        # FAIL CONDITION: Alcohol Detected at any point during the window
        if mq3_state == MQ3_D0_ALARM_THRESHOLD:
            print("\n\n‚ùå TEST FAILED! ALCOHOL DETECTED.")
            
            # --- IMAGE CAPTURE ON FAILURE ---
            if last_detected_frame is not None:
                timestamp = time.strftime("%Y%m%d_%H%M%S")
                filename = os.path.join(IMAGE_SAVE_PATH, f"ALARM_PROOF_{timestamp}.jpg")
                
                # Draw red failure text onto the stored frame
                cv2.putText(last_detected_frame, "ALCOHOL FAIL", (10, 30), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2, cv2.LINE_AA)
                
                cv2.imwrite(filename, last_detected_frame)
                print(f"üì∑ Proof image saved to: {filename}")
                safe_lcd_write("FAIL! Image Saved", "SYSTEM LOCKED")
            else:
                safe_lcd_write("TEST FAILED!", "SYSTEM LOCKED")
                print("‚ö†Ô∏è No face frame captured, skipping image save.")

            
            # üö® REINFORCED SAFETY ENFORCEMENT üö®
            GPIO.output(RELAY_PIN, RELAY_LOCKED_STATE) 
            GPIO.output(LED_PIN, GPIO.HIGH)   # LED ON
            time.sleep(0.05) 
            GPIO.output(RELAY_PIN, RELAY_LOCKED_STATE) 
            print("[CRITICAL] Forced relay pin HIGH/LOCKED.")
            
            send_sms_alert()
            
            # CRITICAL: Enter permanent lock loop
            while True:
                GPIO.output(RELAY_PIN, RELAY_LOCKED_STATE)
                update_gps()
                time.sleep(1)

        safe_lcd_write(f"BLOW NOW {remaining}s", f"D0 State: {'ALARM!' if mq3_state == MQ3_D0_ALARM_THRESHOLD else 'Clear'}")
        time.sleep(0.1)

    # PASS CONDITION: Test window completed without alarm
    print("\n\n‚úÖ TEST PASSED. ENGINE UNLOCKED.")
    GPIO.output(RELAY_PIN, RELAY_UNLOCKED_STATE) # Unlock Relay (Relay LOW)
    GPIO.output(LED_PIN, GPIO.LOW)   # LED OFF
    safe_lcd_write("TEST PASSED", "DRIVE SAFELY")

# --- RUN LOOP ---
if __name__ == "__main__":
    try:
        start_system()
        # Keep main thread alive to maintain the unlocked/locked state
        while True:
            update_gps()
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\n[System] User Shutdown.")
    except Exception as e:
        print(f"\n[CRITICAL ERROR] Unhandled exception: {e}")
    finally:
        # Release Camera and other resources
        if camera:
            camera.release()
            print("[System] Camera released.")

        # CRITICAL SAFETY STEP: Always ensure the vehicle is LOCKED on exit
        print("\n[System] Ensuring vehicle is LOCKED and cleaning up GPIO.")
        GPIO.output(RELAY_PIN, RELAY_LOCKED_STATE) # FORCE LOCK
        GPIO.cleanup()
