import time
import serial
import pynmea2
import RPi.GPIO as GPIO
import board
from RPLCD.i2c import CharLCD

# --- CONFIGURATION ---
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TARGET_PHONE_NUMBER = "+91xxxxxxxxxx" # üö® UPDATE THIS NUMBER!
MQ3_D0_ALARM_THRESHOLD = GPIO.LOW    # MQ-3 D0 pin usually goes LOW when alarm triggers
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

TEST_WINDOW = 5                      # Duration of test in seconds

# --- PINS & PORTS ---
RELAY_PIN = 23                       # Controls vehicle interlock
LED_PIN = 24                         # Visual failure indicator
MQ3_D0_PIN = 18                      # Digital input from MQ-3 D0 pin

GPS_PORT = "/dev/ttyAMA3"            # UART3 (GPIO 4/5)
GSM_PORT = "/dev/serial0"            # Standard UART (GPIO 14/15)

# --- SETUP ---
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Outputs: Relay and LED
GPIO.setup(RELAY_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.output(RELAY_PIN, GPIO.HIGH)    # Initial State: LOCK (HIGH for active-low relay)
GPIO.output(LED_PIN, GPIO.LOW)       # LED OFF

# Input: MQ-3 Digital Output
# We use PULL_UP_DOWN to keep the state stable when not triggered
GPIO.setup(MQ3_D0_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP) 

# Hardware Initialization (Using try/except for robustness)
try:
    lcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)
    lcd.clear()
    print("LCD Connected.")
except:
    lcd = None
    print("LCD Error - Check I2C/Power.")

try:
    gps_serial = serial.Serial(GPS_PORT, baudrate=9600, timeout=0.1)
    gsm_serial = serial.Serial(GSM_PORT, baudrate=9600, timeout=1)
    print("Serial Ports Opened.")
except:
    print("Serial Port Error - Check GPS/GSM Wiring.")

# --- GLOBAL VARIABLES ---
current_lat = "No GPS Fix"
current_lon = ""

# --- HELPER FUNCTIONS ---

def safe_lcd_write(line1, line2=""):
    """Writes to LCD safely, ignoring errors."""
    if lcd:
        try:
            lcd.clear()
            lcd.write_string(line1.ljust(16))
            lcd.cursor_pos = (1, 0)
            lcd.write_string(line2.ljust(16))
        except:
            pass

def update_gps():
    """Reads GPS data non-blockingly."""
    global current_lat, current_lon
    while gps_serial.in_waiting > 0:
        try:
            line = gps_serial.readline().decode('utf-8', errors='replace').strip()
            if line.startswith('$GPGGA'):
                msg = pynmea2.parse(line)
                if msg.gps_qual > 0:
                    current_lat = str(round(msg.latitude, 5))
                    current_lon = str(round(msg.longitude, 5))
        except: pass

def send_sms_alert():
    """Sends SMS alert with location using robust timing."""
    safe_lcd_write("ALARM! Sending SMS", f"Loc: {current_lat}")
    print("‚ö† SENDING SMS ALERT...")

    try:
        # 1. Set to Text Mode
        gsm_serial.write(b'AT+CMGF=1\r\n')
        time.sleep(1.0)
        
        # 2. Send target number and wait for '>' prompt
        gsm_serial.write(f'AT+CMGS="{TARGET_PHONE_NUMBER}"\r\n'.encode('utf-8'))
        time.sleep(1.0) 
        
        # 3. Construct message
        if current_lat == "No GPS Fix":
            loc_msg = "Location: No GPS Fix."
        else:
            loc_msg = f"Location: https://maps.google.com/?q={current_lat},{current_lon}"
            
        message = f"VEHICLE INTERLOCK FAILURE! Alcohol Detected. {loc_msg}"
        gsm_serial.write(message.encode('utf-8'))
        
        # 4. Pause, then send Ctrl+Z (ASCII 26) to signal end
        time.sleep(1.0) 
        gsm_serial.write(bytes([26])) 
        
        time.sleep(5.0) # Wait for transmission completion
        
        response = gsm_serial.read_all().decode('utf-8', errors='ignore').strip()
        if "OK" in response or "+CMGS" in response:
            print("‚úÖ SMS Sent OK.")
        else:
            print(f"‚ùå SMS Failed. Response: {response}")
            
    except Exception as e:
        print(f"SMS Function Error: {e}")

# --- MAIN ROUTINE ---
def start_system():
    print("\n--- VEHICLE INTERLOCK SYSTEM ACTIVE ---")
    safe_lcd_write("INTERLOCK ACTIVE", "Blow Now! (5s)")

    start_time = time.time()
    
    # 5-Second Test Loop
    while (time.time() - start_time) < TEST_WINDOW:
        remaining = int(TEST_WINDOW - (time.time() - start_time)) + 1
        
        # Read the digital status of the MQ-3 (D0)
        mq3_d0_state = GPIO.input(MQ3_D0_PIN)
        
        # Constantly update GPS in the background
        update_gps()
        
        print(f"Time: {remaining}s | D0: {'ALARM' if mq3_d0_state == MQ3_D0_ALARM_THRESHOLD else 'Clear'} | GPS: {current_lat}", end="\r")
        
        # FAIL CONDITION: D0 pin is LOW (indicating alarm triggered)
        if mq3_d0_state == MQ3_D0_ALARM_THRESHOLD:
            print("\n\n‚ùå TEST FAILED! ALCOHOL DETECTED.")
            
            # Lock Vehicle
            GPIO.output(RELAY_PIN, GPIO.HIGH) # Lock
            GPIO.output(LED_PIN, GPIO.HIGH)   # LED ON
            
            send_sms_alert()
            
            safe_lcd_write("TEST FAILED!", "SYSTEM LOCKED")
            
            # Lock loop (Wait until script is manually stopped/rebooted)
            while True:
                update_gps()
                time.sleep(1)

        safe_lcd_write(f"BLOW NOW {remaining}s", f"D0 State: {'ALARM!' if mq3_d0_state == MQ3_D0_ALARM_THRESHOLD else 'Clear'}")
        time.sleep(0.1)

    # PASS CONDITION
    print("\n\n‚úÖ TEST PASSED. ENGINE UNLOCKED.")
    GPIO.output(RELAY_PIN, GPIO.LOW) # Unlock Relay
    GPIO.output(LED_PIN, GPIO.LOW)   # LED OFF
    safe_lcd_write("TEST PASSED", "DRIVE SAFELY")

# --- RUN ---
try:
    start_system()
    # Keep main thread alive to maintain the relay state (Pass/Fail)
    while True:
        update_gps()
        time.sleep(1)
except KeyboardInterrupt:
    print("\nSystem Shutdown")
finally:
    GPIO.cleanup()
